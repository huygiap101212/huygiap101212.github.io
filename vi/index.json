[
{
	"uri": "http://huygiap101212.github.io/vi/5-provisionedconcurrency/5.1-coststructure/",
	"title": "Cấu trúc chi phí",
	"tags": [],
	"description": "",
	"content": "Cấu trúc chi phí Đồng thời được cung cấp tuân theo cấu trúc giá hơi khác so với các hàm Lambda theo yêu cầu. Giá theo yêu cầu tuân theo biểu đồ bên dưới, tính phí người dùng theo yêu cầu và thời lượng thực hiện (GB-giây) . Giá cho AWS Lambda có thể được tìm thấy trên Trang giá.\nCấu trúc giá của Lambda provisioned concurrency hơi khác một chút. Trong khi giá cho số lượng yêu cầu vẫn giữ nguyên, thời lượng thực hiện tính phí (GB-giây) thấp hơn, nhưng có thêm một khoản phí cho thời lượng tính phí đồng thời provisioned (GB-giây).\nTận dụng đồng thời được cung cấp thực sự có thể tiết kiệm hơn so với việc chạy các hàm Lambda theo yêu cầu khi vượt qua một ngưỡng nhất định! Biểu đồ sau đây trực quan hóa giá trên trục y và phần trăm đồng thời được cung cấp đang được sử dụng trên trục x.\nKhi xem biểu đồ, hãy quan sát rằng nếu bạn thêm đồng thời được cung cấp vào một hàm Lambda và sử dụng hơn 60 phần trăm đồng thời được cung cấp, bạn sẽ tiết kiệm được chi phí Lambda so với việc sử dụng các lệnh thực thi theo yêu cầu. Khi sử dụng 100 phần trăm đồng thời được cung cấp, chi phí tiết kiệm được là gần 17 phần trăm.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/1-powertuning/",
	"title": "Điều chỉnh công suất",
	"tags": [],
	"description": "",
	"content": "1. Điều chỉnh công suất Mục tiêu của hội thảo này là hiểu và có được cái nhìn sâu sắc về các hàm AWS Lambda trong quá trình phát triển. Cụ thể là hiểu cách cấu hình tài nguyên cho một hàm Lambda nhất định để tối ưu hóa chi phí và hiệu suất. Mục tiêu là hiểu cách thời gian thực hiện sẽ thay đổi như thế nào khi tăng hoặc giảm bộ nhớ được phân bổ cho hàm Lambda.\nHội thảo này sẽ sử dụng Lambda Power Tuning Project của Alex Casalboni. Dự án này nằm trong Kho Ứng dụng Không máy chủ.\nMột số chi tiết về công cụ này:\nNó giúp bạn điều chỉnh việc phân bổ bộ nhớ cho bất kỳ hàm Lambda nào được triển khai trong tài khoản của bạn.\nCông cụ AWS Lambda Power Tuning là một máy trạng thái được hỗ trợ bởi AWS Step Functions giúp bạn tối ưu hóa các chức năng Lambda về mặt chi phí và/hoặc hiệu suất theo cách dựa trên dữ liệu.\nMáy trạng thái được thiết kế để dễ triển khai và thực thi nhanh. Ngoài ra, nó không phụ thuộc vào ngôn ngữ nên bạn có thể tối ưu hóa bất kỳ hàm Lambda nào trong tài khoản của mình.\nBạn cung cấp hàm Lambda ARN làm đầu vào và máy trạng thái sẽ gọi hàm đó với nhiều cấu hình nguồn (từ 128MB đến 3GB). Sau đó, nó sẽ phân tích tất cả các nhật ký thực thi và đưa ra các đề xuất về cấu hình nguồn tốt nhất để giảm thiểu chi phí và/hoặc tối đa hóa hiệu suất.\nNội dung Triển khai Công cụ điều chỉnh Lambda Power Triển khai hàm Lambda thử nghiệm Phân tích Dọn dẹp tài nguyên "
},
{
	"uri": "http://huygiap101212.github.io/vi/4-eventfiltering/4.2-withouteventfiltering/",
	"title": "Không có lọc sự kiện",
	"tags": [],
	"description": "",
	"content": "Không có lọc sự kiện Bây giờ chúng ta đã có hàng đợi SQS và Lambda, đã đến lúc thiết lập ánh xạ nguồn sự kiện để hàm Lambda nhận tin nhắn từ hàng đợi. Đầu tiên, chúng ta sẽ thiết lập trigger mà không có lọc sự kiện.\nTạo ánh xạ nguồn sự kiện Điều hướng đến Lambda Console và tìm hàm có tên event-filtering-stack-VehicleDataProcessor được tạo bởi sam deploy. Lưu ý sẽ có một ID ngẫu nhiên ở cuối tên. Nhấp vào hàm và trong màn hình tổng quan, chọn Add trigger. Bây giờ chúng ta cần cấu hình hàm Lambda để tiêu thụ tin nhắn từ hàng đợi SQS được tạo bởi SAM. Trong danh sách thả xuống, chọn SQS. Cấu hình các tùy chọn sau: SQS queue: event-filtering-stack-VehicleDataQueue Batch size: 1 (thay đổi từ mặc định là 10) Batch window 0 (mặc định) Nhấp vào Add. Sau đó, bạn sẽ thấy một trigger mới được liệt kê trong tab Configuration với trạng thái là Creating. Đợi vài phút để trạng thái chuyển thành Enabled (bạn cần sử dụng nút làm mới). Bây giờ, bất kỳ tin nhắn nào được gửi đến hàng đợi SQS sẽ được xử lý bởi hàm Lambda này! Kiểm tra ánh xạ nguồn sự kiện Bây giờ chúng ta sẽ kiểm tra xem trigger có hoạt động chính xác không bằng cách gửi 20 tin nhắn đến hàng đợi SQS, từ đó sẽ kích hoạt hàm Lambda. Vì kích thước lô được đặt là 1 nên sẽ có 20 lần gọi.\nTrong terminal CloudShell, chuyển đến thư mục chứa các tệp kiểm tra. cd ~/event-filtering/testevents Trong thư mục này có một script Python đơn giản có tên send-messages.py và một tệp json có tên input.json. Tệp json chứa một mảng gồm 20 tin nhắn kiểm tra để gửi đến hàng đợi SQS. Mỗi sự kiện đại diện cho dữ liệu được thu thập từ một phương tiện.\nĐăng nhập vào SQS Console và tìm hàng đợi có tên event-filtering-stack-VehicleDataQueue. Chọn hàng đợi và sao chép URL. Quay lại terminal CloudShell, gửi các tin nhắn kiểm tra đến hàng đợi SQS bằng cách chạy lệnh sau: sudo pip3 install boto3 python send-messages.py \u0026lt;your-sqs-queue-url\u0026gt; Bây giờ quay lại Lambda Console và chọn tab Monitor, sau đó nhấp vào View CloudWatch logs. Nhấp vào nút Search log group ở đầu màn hình để xem tất cả các tin nhắn log từ hàm Lambda. Trong ô tìm kiếm, nhập Records để lọc các log thành một tin nhắn cho mỗi lần gọi, chỉ hiển thị payload json của tin nhắn. Bạn sẽ thấy có 20 sự kiện đại diện cho 20 lần gọi hàm Lambda (một cho mỗi tin nhắn chúng ta đã gửi đến hàng đợi). "
},
{
	"uri": "http://huygiap101212.github.io/vi/",
	"title": "Tối ưu hóa không máy chủ",
	"tags": [],
	"description": "",
	"content": "Tối ưu hóa không máy chủ (Hiệu suất và Chi phí) Giới thiệu Workshop này sẽ hướng dẫn bạn qua một số kịch bản tối ưu hóa hiệu suất và chi phí.\nCác phương pháp tốt nhất cho Kiến trúc Serverless có thể được tìm thấy trong Serverless Application Lens từ AWS Well Architected Framework.\nWorkshop này có nhiều phần xoay quanh các kịch bản giảm chi phí phổ biến. Tất cả các module được thiết kế để hoàn toàn độc lập, vì vậy bạn có thể hoàn thành từng phần riêng biệt, tuy nhiên, hãy đảm bảo hoàn thành phần Cài đặt trước.\nCác module được sắp xếp theo thứ tự dễ triển khai. Có ba phần chính của workshop.\nPower Tuning và Log Tuning là những phương pháp tốt nhất thường bị bỏ qua, và việc triển khai những chiến lược này không ảnh hưởng đến hoạt động tổng thể của ứng dụng của bạn.\nGraviton2, Event Filtering, Provisioned Concurrency là những cách tiếp cận dựa trên cấu hình có thể yêu cầu một số thay đổi mã hoặc một chút công việc vận hành.\nBạn sẽ học được gì Trong workshop này, bạn sẽ học một số kỹ thuật thực hành tốt nhất để tối ưu hóa workload serverless của bạn nhằm giảm chi phí và cải thiện hiệu suất. Workshop tập trung vào AWS Lambda, tuy nhiên các dịch vụ khác cũng được sử dụng trong suốt quá trình bao gồm:\nAmazon SQS AWS Step Functions AWS AppConfig Nội dung Điều chỉnh công suất Điều chỉnh Nhật ký Graviton2 Lọc sự kiện Đồng thời được cung cấp "
},
{
	"uri": "http://huygiap101212.github.io/vi/4-eventfiltering/4.1-deploy/",
	"title": "Triển khai",
	"tags": [],
	"description": "",
	"content": "Triển khai Truy cập CloudShell Trong terminal CloudShell của bạn, chạy lệnh sau curl \u0026#39;https://static.us-east-1.prod.workshops.aws/public/e637a9ca-6695-4c33-abcd-a66a969f1149/static/code/event-filtering.zip\u0026#39; -o event-filtering.zip Giải nén các tệp và di chuyển vào thư mục chính xác. unzip event-filtering.zip \u0026amp;\u0026amp; cd event-filtering Đóng gói và Triển khai ứng dụng SAM. Việc triển khai này sẽ là một menu tương tác, thông tin cần cung cấp cho menu được liệt kê bên dưới. Trong terminal CloudShell, chạy lệnh sau: sam deploy --guided Stack Name: event-filtering-stack AWS Region: region hiện tại của bạn (ví dụ: us-west-2, us-east-1) Confirm changes before deploy: n Allow SAM CLI IAM role creation: để mặc định Save arguments to configuration file: để mặc định SAM configuration file: để mặc định SAM configuration environment: để mặc định Xác minh mẫu SAM đã được triển khai thành công trong terminal CloudShell. "
},
{
	"uri": "http://huygiap101212.github.io/vi/2-logtuning/2.1-deploysamplefunction/",
	"title": "Triển khai chức năng mẫu",
	"tags": [],
	"description": "",
	"content": "Triển khai Hàm Mẫu Truy cập CloudShell Trong terminal CloudShell, chạy lệnh sau curl \u0026#39;https://static.us-east-1.prod.workshops.aws/public/e637a9ca-6695-4c33-abcd-a66a969f1149/static/code/log-tuning.zip\u0026#39; -o log-tuning.zip Giải nén các tệp, và chuyển vào thư mục đúng. unzip log-tuning.zip \u0026amp;\u0026amp; cd log-tuning Truy cập tài liệu AppConfig documentation để tìm phiên bản hiện tại của phần mở rộng AppConfig. Cuộn xuống trang cho đến khi bạn đến phần Adding the AWS AppConfig Lambda extension trong tài liệu. Sao chép liên kết ARN cho khu vực mà bạn đang thực hiện bài lab này. Bạn sẽ cần giá trị này ở bước tiếp theo. Xây dựng và triển khai ứng dụng trong terminal CloudShell của bạn. sam build \u0026amp;\u0026amp; sam deploy --guided Giữ nguyên các giá trị mặc định cho tất cả các thông báo trừ trường Parameter AppConfigARN. Sao chép ARN mà bạn đã ghi chú trước đó nếu số phiên bản ở cuối khác với giá trị mặc định hiển thị. Stack Name: để mặc định AWS Region: khu vực hiện tại của bạn (ví dụ: us-west-2, us-east-1) Parameter AppConfigARN: DÁN ARN TỪ BƯỚC TRƯỚC Ở ĐÂY Parameter AppConfigProfile: để mặc định Confirm changes before deploy: để mặc định Allow SAM CLI IAM role creation: để mặc định Save arguments to configuration file: để mặc định SAM configuration file: để mặc định SAM configuration environment: để mặc định Khi bạn nhận được thông báo Successfully created, truy cập Lambda console. Trong trường lọc, gõ appconfig để dễ dàng xác định hàm mới được tạo cho bài lab này. Nhấp vào hàm Lambda để vào cửa sổ chi tiết của hàm đó. Trong khu vực ngay dưới Function overview, bạn sẽ thấy một menu. Nhấp vào tab Test. Trong phần Test Event, gõ một cái gì đó như myevent vào trường Name.\nDán json này vào trường sự kiện (đảm bảo xóa bất kỳ nội dung nào trước đó trong đó)\n{ \u0026#34;showextensions\u0026#34;: \u0026#34;function1\u0026#34; } Nhấn nút Save Changes để lưu sự kiện này. Sau đó nhấn nút Test để thực thi hàm và xem kết quả. Khi bài kiểm tra được thực thi, mở rộng phần Details của Execution result. Trong phần Log Output, hãy quan sát thông điệp ghi log được đưa ra bởi hàm, được đánh dấu bằng màu đỏ trong hình dưới đây. "
},
{
	"uri": "http://huygiap101212.github.io/vi/1-powertuning/1.1-deploythelambdapowertuningtool/",
	"title": "Triển khai Công cụ điều chỉnh Lambda Power",
	"tags": [],
	"description": "",
	"content": "Công cụ Điều chỉnh Lambda Power được lưu trữ trong Serverless Application Repository (SAR). SAR cho phép khách hàng nhanh chóng xuất bản và triển khai các ứng dụng serverless. Khách hàng có thể cấu hình quyền SAR để cho phép truy cập vào các tài khoản cụ thể, tài khoản trong Organizations, hoặc truy cập công khai để có khả năng khởi chạy ứng dụng.\nKhởi chạy Công cụ Điều chỉnh Lambda Power Truy cập Serverless Application Repository. Ở khung bên trái, đảm bảo Available Applications được chọn. Trong cửa sổ bộ lọc, nhập AWS Lambda Power Tuning, và đảm bảo Show apps that create custom IAM roles or resource policies được đánh dấu. Chọn ứng dụng aws-lambda-power-tuning. Trên trang Review, configure and deploy, giữ nguyên các mặc định cho mọi thứ. Cuộn xuống dưới cùng, đánh dấu tùy chọn I acknowledge that this app creates custom IAM roles và nhấp vào Deploy Truy cập CloudFormation Console để xem xét quá trình cài đặt công cụ điều chỉnh power. Quá trình này sẽ mất vài phút. Khi stack hoàn thành, bạn có thể chuyển sang phần tiếp theo. "
},
{
	"uri": "http://huygiap101212.github.io/vi/3-graviton2/3.1-deploythelambdapowertuningtool/",
	"title": "Triển khai Công cụ điều chỉnh Lambda Power",
	"tags": [],
	"description": "",
	"content": "Triển khai Công cụ điều chỉnh Lambda Power Chúng ta sẽ bắt đầu bằng việc tạo một hàm Lambda được viết bằng Python và triển khai trên kiến trúc x86. Sau đó, chúng ta sẽ chuyển đổi hàm này sang kiến trúc Graviton2 dựa trên Arm. Chúng ta sẽ sử dụng công cụ điều chỉnh Lambda Power từ Module 1 để so sánh hiệu suất của hai hàm chạy trên các kiến trúc khác nhau.\nCông cụ điều chỉnh Lambda Power được lưu trữ trên Kho ứng dụng Serverless. Kho ứng dụng Serverless (SAR) cho phép khách hàng nhanh chóng xuất bản và triển khai các ứng dụng serverless. Khách hàng có thể cấu hình quyền SAR để cho phép truy cập vào các tài khoản cụ thể, tài khoản trong tổ chức, hoặc truy cập công khai để có khả năng khởi chạy ứng dụng.\nNếu bạn đã triển khai Công cụ điều chỉnh Lambda Power từ Module 1 của workshop này, bạn có thể bỏ qua phần tiếp theo của module này.\nTruy cập Kho ứng dụng Serverless. Trong khung bên trái, đảm bảo Available Applications được chọn. Trong cửa sổ lọc, nhập AWS Lambda Power Tuning, và đảm bảo đã chọn Show apps that create custom IAM roles or resource policies. Chọn ứng dụng aws-lambda-power-tuning. Trên trang Review, configure and deploy, giữ nguyên các giá trị mặc định cho tất cả. Cuộn xuống dưới cùng, chọn tùy chọn I acknowledge that this app creates custom IAM roles và nhấp vào Deploy Truy cập Bảng điều khiển CloudFormation để xem xét quá trình cài đặt công cụ điều chỉnh power. Quá trình này sẽ mất vài phút. Khi stack hoàn tất, bạn có thể chuyển sang phần tiếp theo. "
},
{
	"uri": "http://huygiap101212.github.io/vi/5-provisionedconcurrency/5.2-costsavingopportunities/",
	"title": "Cơ hội tiết kiệm chi phí",
	"tags": [],
	"description": "",
	"content": "Cơ hội tiết kiệm chi phí Bây giờ bạn đã biết rằng việc bật tính năng đồng thời được cung cấp không chỉ giúp chức năng của bạn trở nên siêu sẵn sàng mà còn giảm chi phí Lambda. Bước tự nhiên tiếp theo là hỏi - \u0026ldquo;Làm thế nào để bạn xác định thời điểm bật tính năng đồng thời được cung cấp?\u0026rdquo;. Trước hết, bạn nên tận dụng tính năng đồng thời được cung cấp nếu ứng dụng của bạn nhạy cảm với độ trễ và cần thời gian phản hồi nhất quán. Tiếp theo, bạn cũng có thể khám phá xem việc bật tính năng này có giúp giảm chi phí Lambda của bạn trong khi vẫn nhận được lợi ích về thời gian phản hồi đã đề cập ở trên hay không. Hãy cùng khám phá xem khi nào thì bật tính năng này là hợp lý về mặt tài chính.\nMặc dù luôn khó để dự đoán chính xác lưu lượng Lambda của bạn, tính năng đồng thời được cung cấp mang lại cơ hội tiết kiệm chi phí khi bạn có số lượng thực thi đồng thời nhất quán và/hoặc thay đổi dần dần.\nHãy xem xét biểu đồ sau đây mô tả số lượng thực thi đồng thời mỗi giờ.\nGiả sử số lượng thực thi Lambda đồng thời ổn định trong giờ, bạn có thể cấu hình 30 đồng thời được cung cấp cho hàm Lambda, như thể hiện trong biểu đồ bên dưới. Điều này sẽ cho phép bạn thực thi 30 hàm Lambda đồng thời với chi phí giảm.\nTuy nhiên, bạn cũng có thể thắc mắc, \u0026ldquo;Tôi có thể tăng hoặc giảm mức đồng thời được cung cấp một cách động không?\u0026rdquo;. Câu trả lời ngắn gọn là có, nhưng nó đi kèm với một số cảnh báo. Chúng tôi sẽ đề cập đến cách bạn có thể chỉ định mức đồng thời được cung cấp một cách động tương tự như biểu đồ bên dưới trong các phần tiếp theo.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/2-logtuning/",
	"title": "Điều chỉnh Nhật ký",
	"tags": [],
	"description": "",
	"content": "2. Điều chỉnh Nhật ký Bài thực hành này dựa trên ví dụ trong kho GitHub aws-samples/aws-lambda-extensions được viết bởi Julian Wood. Hãy kiểm tra nó để xem các mẫu và demo tuyệt vời khác.\nGhi nhật ký có thể tác động đến tổng chi phí của giải pháp của bạn. Mỗi hàm Lambda ghi nhật ký stdin, stdout và stderr vào AWS CloudWatch. AWS CloudWatch Logs tính phí sử dụng dựa trên ba chiều, nhật ký được hệ thống tiếp nhận (được đo bằng GB), lưu trữ nhật ký dựa trên GB và nhật ký được phân tích được đo bằng GB dữ liệu được quét. Với sự hiểu biết này, chúng ta có thể điều chỉnh lượng nhật ký được ghi lại và lưu trữ để giảm chi phí cho giải pháp của bạn. Chúng ta sẽ xem xét các điểm này trong mô-đun này.\nTrước tiên, bạn sẽ triển khai một hàm Lambda với tiện ích mở rộng AppConfig. Sau đó, bạn sẽ thiết lập các mức ghi nhật ký trong AppConfig và theo dõi cách hàm Lambda thay đổi hành vi ngay lập tức để đảm bảo bạn có được khả năng hiển thị mức ghi nhật ký chính xác. Sau đó, bạn sẽ sửa đổi các chính sách lưu giữ nhật ký của CloudWatch để các nhật ký sẽ hết hạn sau 7 ngày.\nNội dung Triển khai chức năng mẫu Sửa đổi hành vi ghi nhật ký Sửa đổi việc lưu giữ nhóm nhật ký Dọn dẹp tài nguyên "
},
{
	"uri": "http://huygiap101212.github.io/vi/2-logtuning/2.2-modifyloggingbehavior/",
	"title": "Sửa đổi Hành Vi Ghi Nhật Ký",
	"tags": [],
	"description": "",
	"content": "Sửa đổi Hành Vi Ghi Nhật Ký Trong phần này, chúng ta sẽ sử dụng AWS AppConfig để thay đổi hành vi của hàm Lambda nhằm kích hoạt ghi nhật ký chi tiết hơn. Ghi nhật ký chi tiết chỉ nên được kích hoạt khi cần thiết, ví dụ, khi khắc phục sự cố hoặc trong giai đoạn phát triển. Đầu ra ghi nhật ký nên được giảm bớt khi không cần thiết để tiết kiệm chi phí cho việc lưu trữ và nhập dữ liệu ghi nhật ký. Bài lab này minh họa một cách để quản lý cấu hình đầu ra ghi nhật ký bằng cách sử dụng AWS AppConfig.\nTruy cập AWS AppConfig. Nhấn vào ô DemoExtensionApplication. Chọn tab Configuration profile, sau đó nhấn vào ô LoggingLevel. Trong khu vực Versions, nhấn nút Create để thiết lập một phiên bản cấu hình mới. Thay đổi loglevel từ normal thành debug và nhấn nút Create hosted configuration version. Bạn sẽ thấy có một version 2 trong cấu hình Logging Level. Hãy triển khai điều này đến hàm Lambda của chúng ta với một bản triển khai mới. Nhấn nút Start Deployment. Trên trang Start deployment, chọn các giá trị như hiển thị bên dưới. Sau đó nhấn nút Start Deployment. Environment: Production Hosted configuration version: 2 Deployment strategy: AllAtOnce Khi Deployment status hoàn tất, bạn có thể quay lại hàm appconfig của mình trên Lambda Console. Kiểm tra hàm Lambda của bạn một lần nữa, giống như bạn đã làm trong phần trước. Xem xét đầu ra ghi nhật ký. Nếu bạn không thấy các thông điệp ghi nhật ký debug mới, hãy kiểm tra hàm Lambda một lần nữa, có thể mất một lần gọi hàm để ghi lại trạng thái đã thay đổi của việc ghi nhật ký. "
},
{
	"uri": "http://huygiap101212.github.io/vi/3-graviton2/3.2-deploythebasefunction/",
	"title": "Triển khai chức năng cơ sở",
	"tags": [],
	"description": "",
	"content": "Triển khai chức năng cơ sở Trong phần này của module, bạn sẽ triển khai một hàm Lambda tốn nhiều tài nguyên tính toán được viết bằng Python 3.9. Hàm này xác định số lượng số nguyên tố trong khoảng từ 0 đến 10 triệu.\nMở Bảng điều khiển Lambda.\nNhấp vào nút Create function.\nTạo hàm mới với các giá trị sau và sau đó nhấp vào nút Create function: Author from scratch: đã chọn\nFunction name: lambda-base-function\nRuntime: Python 3.9\nArchitecture: x86_64\nDán đoạn mã Python sau vào trình soạn thảo mã nguồn. Dành một chút thời gian để xem xét mã. Lưu ý rằng bạn có thể làm cho hàm tốn nhiều hoặc ít tài nguyên tính toán hơn bằng cách sửa đổi giá trị N trên dòng 23. import json import math import platform import timeit def primes_up_to(n): primes = [] for i in range(2, n+1): is_prime = True sqrt_i = math.isqrt(i) for p in primes: if p \u0026gt; sqrt_i: break if i % p == 0: is_prime = False break if is_prime: primes.append(i) return primes def lambda_handler(event, context): start_time = timeit.default_timer() N = 1000000 primes = primes_up_to(N) stop_time = timeit.default_timer() elapsed_time = stop_time - start_time response = { \u0026#39;machine\u0026#39;: platform.machine(), \u0026#39;elapsed\u0026#39;: elapsed_time, \u0026#39;message\u0026#39;: \u0026#39;There are {} prime numbers \u0026lt;= {}\u0026#39;.format(len(primes), N) } return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(response) } Điều hướng đến tab Configuration và tab phụ General configuration để cập nhật thời gian chờ của hàm bằng cách nhấp vào nút Edit. Cập nhật giá trị Timeout trên trang Edit basic settings thành 3 phút và nhấp vào Save. Tạo một bài kiểm tra cho hàm mới bằng cách nhấp vào nút test trên màn hình mã nguồn. Trên màn hình Configure test event, đặt tên cho bài kiểm tra như test1 và nhấp vào Save. Bây giờ nhấp vào nút Test và quan sát mã trạng thái 200. Thu thập số liệu từ Công cụ điều chỉnh Lambda Power Sao chép Function ARN và lưu vào trình soạn thảo văn bản hoặc không gian làm việc tạm thời. Bạn sẽ cần giá trị này sau. Lưu ý: Để tab hàm Lambda này mở trong trình duyệt của bạn khi bạn tiếp tục.\nMở một tab trình duyệt mới và điều hướng đến bảng điều khiển AWS Step Functions.\nMở Máy trạng thái Power Tuning bằng cách nhấp vào máy trạng thái bạn đã triển khai trong phần trước.\nNhấp vào nút Start Execution để bắt đầu phân tích hàm bạn đã tạo trước đó. Dán JSON sau vào trường Execution input. Hãy cẩn thận cập nhật Lambda ARN bằng giá trị bạn đã lưu trong không gian làm việc tạm thời từ bước 1. Nhấp vào Start execution. { \u0026#34;lambdaARN\u0026#34;: \u0026#34;YOUR LAMBDA ARN HERE\u0026#34;, \u0026#34;powerValues\u0026#34;: [128, 256, 512, 1024, 2048, 3008], \u0026#34;num\u0026#34;: 10, \u0026#34;payload\u0026#34;: \u0026#34;{}\u0026#34;, \u0026#34;parallelInvocation\u0026#34;: true, \u0026#34;strategy\u0026#34;: \u0026#34;cost\u0026#34; } Theo dõi trình kiểm tra đồ thị khi Công cụ điều chỉnh Power thực hiện phân tích của nó. Đợi cho đến khi việc phân tích hàm của bạn hoàn tất, hiển thị Succeeded trong trường Execution Status. Điều hướng đến tab Execution output để sao chép URL visualization. Lưu URL này vào trình soạn thảo văn bản tạm thời của bạn và sau đó dán URL vào một tab trình duyệt mới để xem kết quả được trực quan hóa. "
},
{
	"uri": "http://huygiap101212.github.io/vi/1-powertuning/1.2-deploytestlambafunction/",
	"title": "Triển khai hàm Lambda thử nghiệm",
	"tags": [],
	"description": "",
	"content": "Giờ đây bạn đã cài đặt công cụ điều chỉnh power, bước tiếp theo là chạy một hàm AWS Lambda với nó. Trong phần này của module, bạn sẽ triển khai một hàm Lambda để kiểm tra việc sử dụng Công cụ Điều chỉnh Power. Hàm này sử dụng nhiều bộ nhớ, sử dụng các ma trận.\nTriển khai hàm Hãy chắc chắn triển khai hàm này trong cùng region với Công cụ Điều chỉnh Lambda Power của bạn\nTruy cập AWS Lambda Console. Nhấp vào tùy chọn Create Function ở góc trên bên phải của bảng điều khiển. Trên trang Create function, nhập các giá trị sau, để các giá trị còn lại ở mặc định và nhấp Create Function. Author from scratch: đã chọn Function Name: lambda-power-tuning-test Runtime: Python 3.8 Architecture: x86_64 Trong khung Lambda Designer, nhấp vào Layers hoặc cuộn xuống cuối trang, đến khung Layers. Nhấp vào nút Add Layer. Trên trang Add layer, nhập các giá trị sau và nhấp vào nút Add. Layer Source: AWS Layers đã chọn AWS layers: AWSLambda-Python38-SciPy1x đã chọn Version: phiên bản mới nhất có sẵn đã chọn Tìm khung Function Code và dán đoạn mã sau vào màn hình biên tập. import json import numpy as np from scipy.spatial import ConvexHull def lambda_handler(event, context): ms = 100 print(\u0026#34;Printing from version on 10302020 - size of matrix\u0026#34;, ms,\u0026#34;x\u0026#34;,ms) print(\u0026#34;\\nFilling the matrix with random integers below 100\\n\u0026#34;) matrix_a = np.random.randint(100, size=(ms, ms)) print(matrix_a) print(\u0026#34;random matrix_b =\u0026#34;) matrix_b = np.random.randint(100, size=(ms, ms)) print(matrix_b) print(\u0026#34;matrix_a * matrix_b = \u0026#34;) print(matrix_a.dot(matrix_b)) num_points = 10 print(num_points, \u0026#34;random points:\u0026#34;) points = np.random.rand(num_points, 2) for i, point in enumerate(points): print(i, \u0026#39;-\u0026gt;\u0026#39;, point) hull = ConvexHull(points) print(\u0026#34;The smallest convex set containing all\u0026#34;, num_points, \u0026#34;points has\u0026#34;, len(hull.simplices), \u0026#34;sides,\\nconnecting points:\u0026#34;) for simplex in hull.simplices: print(simplex[0], \u0026#39;\u0026lt;-\u0026gt;\u0026#39;, simplex[1]) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; }, \u0026#39;body\u0026#39;: \u0026#39;\u0026#39;, \u0026#34;isBase64Encoded\u0026#34;: False } Nhấn Deploy để triển khai mã mới cho hàm. Trong menu hàm, nhấn vào tùy chọn Configuration. Nhấn vào Edit trong bảng General Configuration. Trên trang Edit basic settings, nhập các giá trị sau, giữ lại các giá trị còn lại ở mặc định và nhấn nút Save: Memory: 3008 Timeout: 5 minutes Kiểm tra hàm Trong menu hàm, chọn tab Test. Nhập một giá trị tên và nhấn nút Test để kích hoạt một bài kiểm tra cho hàm. Name: testevent Sau khi hàm đã thực thi, bạn sẽ thấy một thông báo thành công trên màn hình. Cuộn lên đầu trang hàm để sao chép ARN của hàm, bạn sẽ cần giá trị này cho phần tiếp theo của bài lab. "
},
{
	"uri": "http://huygiap101212.github.io/vi/5-provisionedconcurrency/5.3-staticprovisionedconcurrency/",
	"title": "Đồng thời được cung cấp tĩnh",
	"tags": [],
	"description": "",
	"content": "Đồng thời được cung cấp tĩnh Bây giờ chúng ta sẽ tạo một hàm Lambda và cấu hình độ đồng thời được cung cấp.\nĐiều hướng đến Lambda console và nhấp vào nút Create function màu cam. Vì chúng ta chỉ đang cấu hình độ đồng thời được cung cấp, chúng ta sẽ sử dụng một blueprint để tạo hàm của mình. Chọn Use a blueprint và gõ hello-world-python để tìm hàm Lambda của chúng ta. Sau đó nhấp vào configure để tiếp tục. Đặt tên cho hàm Lambda của bạn là provisioned-concurrency-test. Giữ nguyên tất cả các giá trị còn lại với tùy chọn mặc định đã chọn. Nhấn vào Create function.\nKhi bạn đã tạo hàm của mình, bạn sẽ phải tạo một alias hoặc phát hành một phiên bản để cấu hình độ đồng thời được cung cấp.\nCác phiên bản thường được sử dụng để quản lý việc triển khai hàm của bạn. Chúng cho phép nhanh chóng nhìn thấy mã đã hoạt động trước đó cũng như khả năng quay lại phiên bản trước nếu một triển khai mới không thành công. Các alias giống như một con trỏ tới một phiên bản hàm cụ thể, giúp bạn tiết kiệm công sức khi phải chỉ tới một phiên bản Lambda mới mỗi khi có một triển khai mới.\nĐể phát hành một phiên bản mới của hàm Lambda của bạn, điều hướng đến tab Versions và nhấp vào Publish new version. Bạn có thể để trống mô tả và nhấn nút Publish màu cam để phát hành phiên bản đầu tiên của hàm.\nBây giờ bạn đã phát hành một phiên bản của hàm Lambda, bạn có thể cấu hình độ đồng thời được cung cấp cho phiên bản này. Điều hướng đến tab Configuration, chọn Provisioned Concurrency từ menu bên trái, và nhấp vào nút Edit. Trên trang Configure provisioned concurrency, nhập 30 cho độ đồng thời được cung cấp của bạn, và nhấn nút Save. Khi bạn kích hoạt độ đồng thời được cung cấp cho một hàm, dịch vụ Lambda sẽ khởi tạo số lượng môi trường thực thi được yêu cầu để chúng có thể sẵn sàng phản hồi các yêu cầu gọi hàm. Điều này tránh độ trễ trong việc tạo một môi trường thực thi mới theo yêu cầu, thường được gọi là \u0026ldquo;cold start\u0026rdquo;. Hiện tại chúng ta có 30 môi trường thực thi sẵn sàng và có sẵn để xử lý 30 lần thực thi đồng thời. Bất kỳ lần thực thi nào vượt quá 30 sẽ được xử lý theo cách tiêu chuẩn theo yêu cầu.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/3-graviton2/",
	"title": "Graviton2",
	"tags": [],
	"description": "",
	"content": "3. Graviton2 Vào tháng 9 năm 2021, AWS đã công bố rằng các Hàm AWS Lambda sẽ có tùy chọn được hỗ trợ bởi Bộ xử lý AWS Gravition2, một kiến trúc dựa trên Arm được thiết kế và xây dựng bởi AWS.\nCác hàm Lambda được cung cấp bởi bộ xử lý AWS Graviton2 có thể cải thiện hiệu suất/giá tốt hơn tới 34% so với x86. Các hàm Graviton2, sử dụng kiến ​​trúc bộ xử lý dựa trên Arm, được thiết kế để cung cấp hiệu suất tốt hơn tới 19% với chi phí thấp hơn 20% cho nhiều khối lượng công việc Không máy chủ, chẳng hạn như web và phần phụ trợ di động, dữ liệu và xử lý phương tiện. Với độ trễ thấp hơn và hiệu suất tốt hơn, các hàm được cung cấp bởi bộ xử lý AWS Graviton2 lý tưởng để cung cấp năng lượng cho các ứng dụng Không máy chủ quan trọng.\nCải thiện giá/hiệu suất sẽ khác nhau tùy theo thời gian chạy và mã nguồn. Trong mô-đun này, chúng ta sẽ tìm hiểu phương pháp kiểm tra mã mẫu với cả hai kiến ​​trúc và hoàn thành phân tích giá/hiệu suất.\nNội dung Triển khai Công cụ Điều chỉnh Năng lượng Lambda Triển khai chức năng cơ sở Triển khai hàm Graviton2 Dọn dẹp tài nguyên "
},
{
	"uri": "http://huygiap101212.github.io/vi/1-powertuning/1.3-analysis/",
	"title": "Phân tích",
	"tags": [],
	"description": "",
	"content": "Bây giờ bạn đã triển khai công cụ tối ưu hóa năng lượng và một hàm Lambda thử nghiệm, đã đến lúc tìm kích thước bộ nhớ tốt nhất cho hàm này. Công cụ Tối ưu hóa Năng lượng sẽ chạy hàm thử nghiệm của chúng ta với nhiều kích thước bộ nhớ khác nhau để giúp xác định cấu hình nào cung cấp chi phí và hiệu suất tốt nhất. Trong phần này, chúng ta sẽ đi qua các bước để phân tích cấu hình của hàm.\nTrong một tab trình duyệt mới, mở Step Function console. Trong bảng điều khiển bên trái, đảm bảo rằng State Machines được chọn. Chọn powerTuningStateMachine từ danh sách State Machines. Trong trang powerTuningStateMachine mới mở, nhấn nút Start Execution. Một cửa sổ Start execution sẽ mở ra. Thay thế thông tin trong trường Input bằng json dưới đây. Đảm bảo thay thế giá trị của trường lambdaARN bằng ARN bạn đã sao chép ở giai đoạn trước. Sau đó, nhấn nút Start execution. { \u0026#34;lambdaARN\u0026#34;: \u0026#34;ARN CỦA BẠN Ở ĐÂY\u0026#34;, \u0026#34;powerValues\u0026#34;: [128, 256, 512, 1024, 2048, 3008], \u0026#34;num\u0026#34;: 10, \u0026#34;payload\u0026#34;: \u0026#34;{}\u0026#34;, \u0026#34;parallelInvocation\u0026#34;: true, \u0026#34;strategy\u0026#34;: \u0026#34;cost\u0026#34; } Đợi cho việc thực thi hoàn tất. Khi Execution Status hiển thị Succeeded, nhấn vào tab menu Execution input and output. Sao chép URL từ trường visualization và dán nó vào một tab trình duyệt mới để xem xét kết quả. Hình ảnh này cung cấp cho bạn cả gợi ý và đầu ra hình ảnh của kết quả thử nghiệm từ Công cụ Tối ưu hóa Năng lượng. Từ phân tích, chúng ta có thể kết luận rằng để tối ưu hóa hàm cho chi phí thấp nhất, cấu hình bộ nhớ 512MB sẽ là tốt nhất. Để tối ưu hóa hàm cho hiệu suất, cấu hình bộ nhớ 512MB cũng sẽ là tốt nhất.\nNếu hàm ban đầu được cấu hình với 128MB, thì việc tăng bộ nhớ lên 512MB có thể giảm chi phí VÀ cải thiện hiệu suất. Việc tăng bộ nhớ trên 512MB không làm giảm thời gian gọi hàm và do đó chỉ dẫn đến chi phí cao hơn. Điều này cho thấy tầm quan trọng của việc tối ưu hóa các hàm Lambda trong môi trường của bạn.\nChương trình đào tạo này minh họa sự đánh đổi giữa chi phí và hiệu suất khi thiết kế và thực thi các hàm Lambda. Ứng dụng Tuning Lambda có thể được sử dụng để đánh giá các yêu cầu tài nguyên và phân tích hồ sơ chi phí. Ứng dụng Tối ưu hóa Năng lượng sẽ được sử dụng trong mô-đun Graviton sau để phân tích hiệu suất của một hàm trên các kiến trúc tính toán khác nhau.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/4-eventfiltering/4.3-usingeventfiltering/",
	"title": "Sử dụng Lọc Sự kiện",
	"tags": [],
	"description": "",
	"content": "Sử dụng Lọc Sự kiện Trong phần này, chúng ta sẽ tạo lại ánh xạ nguồn sự kiện đến hàng đợi SQS với một bộ lọc để đảm bảo chỉ xử lý những tin nhắn có tire_pressure \u0026lt; 32. Các tin nhắn không khớp với tiêu chí lọc sẽ tự động bị xóa khỏi hàng đợi.\nTạo ánh xạ nguồn sự kiện với bộ lọc Điều hướng đến Lambda Console và duyệt đến hàm Lambda được tạo bởi mẫu SAM có tên event-filtering-stack-VehicleDataProcessor. Chỉnh sửa hàm, nhấp vào tab Configuration và xóa trigger SQS đã tạo trong phần trước. Sau khi trigger hiện tại đã bị xóa (bạn có thể cần làm mới), nhấp vào Add trigger để tạo một ánh xạ nguồn sự kiện mới. Cấu hình trigger SQS như trước nhưng lần này thêm Filter criteria dưới Additional settings. Sử dụng tiêu chí lọc dưới đây để lọc ra các tin nhắn có tire_pressure từ 32 trở lên\n{ \u0026#34;body\u0026#34;: { \u0026#34;tire_pressure\u0026#34;: [{\u0026#34;numeric\u0026#34;: [\u0026#34;\u0026lt;\u0026#34;, 32]}] } } Đợi trạng thái trigger chuyển thành enabled trước khi tiếp tục (bạn có thể phải sử dụng nút làm mới). Kiểm tra bộ lọc sự kiện Trong terminal CloudShell, chạy lại script send-messages.py để gửi 20 sự kiện tương tự đến hàng đợi. Ghi chú thời gian bạn bắt đầu kiểm tra vì bạn sẽ cần điều này để xác nhận số lần gọi. cd ~/event-filtering/testevents/ sudo pip3 install boto3 python send-messages.py \u0026lt;your-sqs-queue-url\u0026gt; Có 7/20 sự kiện khớp với tiêu chí lọc và sẽ gọi hàm Lambda. Các sự kiện khác sẽ bị xóa khỏi hàng đợi.\nBây giờ quay lại Lambda Console và chọn tab Monitor, sau đó nhấp vào View CloudWatch logs. Nhấp vào nút Search log group ở đầu màn hình để xem tất cả các tin nhắn log từ hàm Lambda. Trong ô tìm kiếm, nhập Records để lọc các log thành một tin nhắn cho mỗi lần gọi, chỉ hiển thị payload json của tin nhắn. Kể từ khi bạn bắt đầu kiểm tra mới nhất, bạn sẽ thấy chỉ có 7 sự kiện đã được xử lý bởi Lambda thay vì tất cả 20. "
},
{
	"uri": "http://huygiap101212.github.io/vi/2-logtuning/2.3-modifyloggroupretention/",
	"title": "Sửa đổi việc lưu giữ nhóm nhật ký",
	"tags": [],
	"description": "",
	"content": "Sửa đổi việc lưu giữ nhóm nhật ký Trong phần trước, bạn đã học cách quản lý cấu hình hàm để sửa đổi mức đầu ra nhật ký của mã của bạn. Trong phần này, bạn sẽ giảm thời gian lưu giữ nhật ký để giúp giảm chi phí lưu trữ nhật ký.\nTrong hàm Lambda từ phần trước trên thanh menu Lambda, nhấp vào tab Monitor. Sau đó nhấp vào nút View CloudWatch logs. Thao tác này sẽ mở một cửa sổ trình duyệt mới, tại nhóm nhật ký cho hàm demo AppConfig của chúng ta. Quan sát giá trị Retention được liệt kê trong phần details. Trong menu thả xuống Actions, chọn tùy chọn Edit retention settings. Chọn 1 week (7 days) từ menu thả xuống trong trường Expire events after, và nhấp Save. Xác nhận rằng thời gian Retention giờ đã được đặt thành 1 tuần trong Log Group Details Page. Sau khi thời gian này trôi qua, những nhật ký đó sẽ bị loại bỏ, tiết kiệm chi phí lưu trữ. "
},
{
	"uri": "http://huygiap101212.github.io/vi/3-graviton2/3.3-deploythegraviton2function/",
	"title": "Triển khai Hàm Graviton2",
	"tags": [],
	"description": "",
	"content": "Triển khai Hàm Graviton2 Trong phần này của mô-đun, bạn sẽ sửa đổi hàm Lambda từ phần trước để triển khai trên kiến trúc dựa trên Arm Graviton2 thay vì kiến trúc x86.\nTriển khai Hàm Lambda Graviton2 arm_64 Quay lại tab hàm Lambda của bạn hoặc mở một tab mới trong trình duyệt đến trang chính của Lambda console và điều hướng đến lambda-base-function mà chúng ta đã tạo trong phần trước. Cuộn xuống cuối trang để sửa đổi Runtime settings bằng cách nhấp vào nút Edit. Thay đổi kiến trúc thời gian chạy sang loại Graviton2 bằng cách chọn arm64 và sau đó nhấp vào nút Save. Bây giờ nhấp vào nút Test và quan sát mã trạng thái 200. Thu thập số liệu từ Lambda Power Tuning Tool Sao chép Function ARN mà bạn đã lưu trước đó vào trình soạn thảo văn bản hoặc không gian làm việc tạm thời của bạn. Để tab trình duyệt này mở.\nMở Lambda Power Tuning Tool mà bạn đã sử dụng trước đó. Điều này có thể được thực hiện bằng cách truy cập AWS Step Functions console. Nhấp vào nút Start execution để bắt đầu phân tích hàm mà bạn vừa sửa đổi để sử dụng kiến trúc arm64. Dán JSON sau vào trường Execution input. Hãy chú ý cập nhật Lambda ARN với giá trị bạn đã lưu trong không gian tạm thời của bạn từ bước 1. Nhấp vào Start execution. { \u0026#34;lambdaARN\u0026#34;: \u0026#34;ARN LAMBDA CỦA BẠN Ở ĐÂY\u0026#34;, \u0026#34;powerValues\u0026#34;: [128, 256, 512, 1024, 2048, 3008], \u0026#34;num\u0026#34;: 10, \u0026#34;payload\u0026#34;: \u0026#34;{}\u0026#34;, \u0026#34;parallelInvocation\u0026#34;: true, \u0026#34;strategy\u0026#34;: \u0026#34;cost\u0026#34; } Theo dõi biểu đồ khi Công cụ Điều chỉnh Năng lượng thực hiện phân tích. Đợi cho đến khi phân tích hàm của bạn hoàn tất, hiển thị Succeeded trong trường Trạng thái Thực thi. Chuyển đến tab Execution input and output để sao chép URL visualization. Dán URL vào một tab trình duyệt mới để xem kết quả được trực quan hóa. Bây giờ bạn nên có hai tab Trực quan hóa Điều chỉnh Năng lượng Lambda mở trong trình duyệt của bạn. Giữ tab trình duyệt này mở.\nSo sánh các chỉ số hiệu suất từ mỗi hàm Để so sánh kết quả giữa hai kiến trúc, nhấp vào nút Compare trên trực quan hóa hiện tại. Sao chép URL từ tab trình duyệt trực quan hóa khác đang mở và dán nó vào trường. Ở lời nhắc tiếp theo, nhập tên x86. Đặt tên cho trực quan hóa hiện tại là arm64. Bây giờ bạn có thể nhìn thấy trực quan cả so sánh Thời gian Gọi và Chi phí giữa các hàm kiến trúc x86 và arm64. Quan sát rằng hàm arm64 hoạt động tốt hơn cả về Chi phí và Thời gian Gọi trong trường hợp này. "
},
{
	"uri": "http://huygiap101212.github.io/vi/1-powertuning/1.4-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Xóa Công cụ Tối ưu hóa Năng lượng Lambda LƯU Ý: nếu bạn tiếp tục với mô-đun Graviton2, bạn không cần phải xóa công cụ Tối ưu hóa Năng lượng Lambda vì công cụ này cũng sẽ được sử dụng trong mô-đun đó.\nĐiều hướng đến trang CloudFormation Console.\nChọn stack serverlessrepo-aws-lambda-power-tuning và nhấn nút Delete.\nXóa Hàm Lambda Thử nghiệm Điều hướng đến trang Lambda Console.\nChọn Functions trong menu bên trái. Chọn hàm lambda-power-tuning-test, chọn nó và nhấn Actions \u0026gt; Delete.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/2-logtuning/2.4-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Di chuyển đến Bảng điều khiển AppConfig. Chọn DemoExtensionApplication \u0026gt; Logging Level. Chọn phiên bản 2 và chọn Delete. (Bạn cần xóa phiên bản này trước khi xóa stack CloudFormation vì nó được tạo thủ công). Chọn Functions trên menu bên trái. Chọn hàm appconfig-app-Function1-ytv4JHcOiRtw và nhấp vào Actions \u0026gt; Delete. "
},
{
	"uri": "http://huygiap101212.github.io/vi/3-graviton2/3.4-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Xóa AWS Lambda Power Tuning Tool Để xóa Lambda Power Tuning Tool, điều hướng đến trang CloudFormation.\nTìm kiếm lambda-power.\nChọn nút radio bên cạnh stack power-tuning và sau đó nhấp vào nút Delete. Xóa Hàm Lambda Để xóa Hàm Lambda, điều hướng đến Lambda Console.\nTìm kiếm \u0026rsquo;lambda-base'\nChọn hộp kiểm bên cạnh lambda-base-function. Sau đó mở rộng nút Actions và nhấp vào tùy chọn Delete. "
},
{
	"uri": "http://huygiap101212.github.io/vi/4-eventfiltering/4.4-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Trong CloudShell terminal hãy chạy các lệnh bên dưới để xóa mẫu SAM. cd ~/event-filtering/ sam delete --stack-name event-filtering-stack --no-prompts "
},
{
	"uri": "http://huygiap101212.github.io/vi/5-provisionedconcurrency/5.4-dynamicprovisionedconcurrency/",
	"title": "Đồng thời được cung cấp động",
	"tags": [],
	"description": "",
	"content": "Đồng thời được cung cấp động Trong phần trước, chúng ta đã cấu hình 30 độ đồng thời được cung cấp cho hàm Lambda mẫu mà chúng ta vừa tạo. Bây giờ hãy cùng tìm hiểu cách cấu hình độ đồng thời được cung cấp động. Chúng ta sẽ sử dụng Application Auto Scaling để thiết lập độ đồng thời được cung cấp động. Tùy chọn theo dõi mục tiêu trong ứng dụng tự động mở rộng sẽ tăng hoặc giảm số lượng tài nguyên dựa trên giá trị mục tiêu cho một chỉ số CloudWatch cụ thể. Trong trường hợp của chúng ta, chúng ta sẽ sử dụng LambdaProvisionedConcurrencyUtilization làm chỉ số mục tiêu, và tăng hoặc giảm độ đồng thời được cung cấp cho một hàm Lambda. Danh sách đầy đủ các chỉ số theo dõi mục tiêu cho tất cả các dịch vụ khác có thể được tìm thấy trong tài liệu của chúng tôi.\nMở Lambda Console và nhấp vào nút Create function.\nTạo hàm mới với các giá trị sau và sau đó nhấp vào nút Create function:\nAuthor from scratch: selected\nFunction name: ProvisionedConcurrency\nRuntime: Python 3.9\nArchitecture: x86_64\nTrong terminal CloudShell của bạn, chạy lệnh sau. aws application-autoscaling register-scalable-target \\ --service-namespace lambda \\ --scalable-dimension lambda:function:ProvisionedConcurrency \\ --resource-id function:provisioned-concurrency-test:1 \\ --min-capacity 0 \\ --max-capacity 50 Chạy lệnh sau để tạo tệp cấu hình chỉ định giá trị mục tiêu cho chỉ số LambdaProvisionedConcurrencyUtilization là 0.7. echo \u0026#34;{\\\u0026#34;TargetValue\\\u0026#34;: 0.7, \\\u0026#34;PredefinedMetricSpecification\\\u0026#34;: {\\\u0026#34;PredefinedMetricType\\\u0026#34;: \\\u0026#34;LambdaProvisionedConcurrencyUtilization\\\u0026#34;}}\u0026#34; \u0026gt; config.json Bây giờ, sử dụng lệnh sau để áp dụng chính sách tự động mở rộng với tệp config.json mới. aws application-autoscaling put-scaling-policy \\ --service-namespace lambda \\ --scalable-dimension lambda:function:ProvisionedConcurrency \\ --resource-id function:provisioned-concurrency-test:1 \\ --policy-name lambda-target-tracking-scaling-policy --policy-type TargetTrackingScaling \\ --target-tracking-scaling-policy-configuration file://config.json Nếu lệnh thực thi thành công, bạn sẽ thấy nó trả về một PolicyARN với hai báo động. AlarmHigh và AlarmLow.\nViệc tự động mở rộng mà chúng ta vừa thiết lập khá đơn giản. Chúng ta đã cấu hình hai báo động. Báo động đầu tiên kích hoạt khi mức sử dụng độ đồng thời được cung cấp liên tục vượt quá 70 phần trăm. Báo động thứ hai kích hoạt khi mức sử dụng liên tục thấp hơn 63 phần trăm (90 phần trăm của mục tiêu 70 phần trăm). Mỗi báo động sẽ phân bổ thêm độ đồng thời được cung cấp hoặc giảm độ đồng thời được cung cấp để điều chỉnh giá trị sử dụng.\nĐiều hướng đến trang CloudWatch console và nhấp vào Alarms và sau đó All alarms trong thanh điều hướng bên trái. Nó sẽ hiển thị hai báo động mà bạn vừa thiết lập, chúng sẽ ở trạng thái Insufficient data vì báo động vừa mới được thiết lập. Cột Conditions hiển thị điều kiện mà nó cần đáp ứng để kích hoạt từng báo động. Nếu bạn muốn biết điều kiện cụ thể mà nó cần đáp ứng, bạn có thể nhấp vào tên báo động để xem chi tiết.\nHai chính sách tự động mở rộng được thiết lập bởi dịch vụ tự động mở rộng ứng dụng như sau.\nScaling out: ProvisionedConcurrencyUtilization \u0026gt; 0.7 trong 3 điểm dữ liệu trong 3 phút\nScaling in: ProvisionedConcurrencyUtilization \u0026lt; 0.63 trong 15 điểm dữ liệu trong 15 phút\nVì đây là một chính sách tự động theo dõi mục tiêu được quản lý, các quy tắc trên có thể thay đổi bất kỳ lúc nào. Điều quan trọng là phải hiểu rõ các quy tắc chính xác phía sau chính sách tự động mở rộng mà bạn đã thiết lập, vì điều này sẽ xác định hiệu quả của chính sách. Nếu bạn có một khối lượng công việc cực kỳ động, trong đó số lượng thực thi đồng thời thay đổi rất nhiều, có thể chính sách tự động mở rộng sẽ không tối ưu và cuối cùng tốn kém hơn so với việc chỉ thực thi các hàm Lambda theo yêu cầu. Theo các ngưỡng báo động đã chỉ định ở trên, sẽ mất ít nhất 3 phút để mở rộng và 15 phút để thu hẹp.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/4-eventfiltering/",
	"title": "Lọc sự kiện",
	"tags": [],
	"description": "",
	"content": "4. Lọc sự kiện Khi một hàm AWS Lambda được cấu hình với một nguồn sự kiện, dịch vụ Lambda kích hoạt một hàm Lambda cho mỗi tin nhắn hoặc bản ghi. Hành vi chính xác phụ thuộc vào lựa chọn nguồn sự kiện và cấu hình của ánh xạ nguồn sự kiện. Ánh xạ nguồn sự kiện xác định cách dịch vụ Lambda xử lý các tin nhắn hoặc bản ghi đến từ nguồn sự kiện.\nTại re:Invent 2021, AWS đã công bố khả năng lọc tin nhắn trước khi gọi hàm Lambda. Việc lọc được hỗ trợ cho các nguồn sự kiện sau:\nAmazon DynamoDB Amazon Kinesis Data Streams Amazon MQ Amazon Managed Streaming for Apache Kafka (Amazon MSK) Apache Kafka tự quản lý Amazon Simple Queue Service (Amazon SQS) Lọc sự kiện giúp giảm các yêu cầu gửi đến hàm Lambda của bạn, có thể đơn giản hóa mã và có thể giảm tổng chi phí. Trong bài thực hành này, chúng ta sẽ khám phá việc lọc sự kiện trên một hàm Lambda được đăng ký vào một hàng đợi SQS như được hiển thị trong sơ đồ dưới đây.\nChúng ta sẽ sử dụng cùng một ví dụ về dữ liệu IoT của phương tiện từ blog ra mắt lọc sự kiện. Chúng ta chỉ quan tâm đến việc xử lý các bản ghi SQS nơi áp suất lốp (tire_pressure) nhỏ hơn 32 PSI, điều này có thể chỉ ra vấn đề với lốp xe.\nNội dung Triển khai Không có Lọc Sự kiện Sử dụng Lọc Sự kiện Dọn dẹp tài nguyên "
},
{
	"uri": "http://huygiap101212.github.io/vi/5-provisionedconcurrency/",
	"title": "Đồng thời được cung cấp",
	"tags": [],
	"description": "",
	"content": "5. Đồng thời được cung cấp Đồng thời Được Cung cấp là một tính năng giữ cho các hàm được khởi tạo và siêu sẵn sàng để đáp ứng các yêu cầu trong khoảng thời gian mili giây hai chữ số. Điều này lý tưởng để triển khai các dịch vụ tương tác, như backend web và di động, các microservice nhạy cảm với độ trễ, và các API đồng bộ yêu cầu phản hồi ngay lập tức. Trong phần này của hội thảo, bạn sẽ kích hoạt đồng thời được cung cấp cho một trong các hàm Lambda mà bạn đã tạo. Chúng tôi sẽ chỉ ra cách tính năng này không chỉ có thể giúp hàm của bạn siêu sẵn sàng, mà còn giảm chi phí hàm Lambda của bạn.\nNội dung Cấu trúc Chi phí Cơ hội Tiết kiệm Chi phí Đồng thời Được Cung cấp Tĩnh Đồng thời được cung cấp động Kết luận và dọn dẹp "
},
{
	"uri": "http://huygiap101212.github.io/vi/5-provisionedconcurrency/5.5-conclusionandcleanup/",
	"title": "Kết luận và Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Độ đồng thời được cung cấp không chỉ có thể được sử dụng để giảm thời gian phản hồi của hàm Lambda của bạn, mà còn có thể được tận dụng để giảm chi phí Lambda của bạn. Độ đồng thời được cung cấp cũng có thể được sử dụng kết hợp với Compute Savings Plans để tiết kiệm thêm. Tuy nhiên, vì độ đồng thời được cung cấp không được sử dụng đầy đủ có thể tốn kém hơn so với các hàm Lambda theo yêu cầu, chúng tôi khuyên bạn nên theo dõi chặt chẽ các chỉ số Lambda để xác nhận rằng bạn thực sự đang tiết kiệm chi phí bằng cách tận dụng độ đồng thời được cung cấp.\nDọn dẹp Điều hướng đến Lambda Console\nChọn hai hàm, sau đó sử dụng menu drop down Actions, nhấn Delete để xóa hàm.\nTiếp theo, điều hướng đến CloudWatch console .\nĐiều hướng vào bảng điều khiển Alarms. Gõ TargetTracking vào thanh tìm kiếm để xác định các báo động mà chúng ta đã tạo trong phần trước.\nChọn cả hai báo động TargetTracking, và sau đó sử dụng menu drop down Actions, nhấn Delete để xóa các báo động.\n"
},
{
	"uri": "http://huygiap101212.github.io/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://huygiap101212.github.io/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]